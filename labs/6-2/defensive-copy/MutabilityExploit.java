import java.util.List;

/**
 * MutabilityExploit.java
 * 
 * This class demonstrates how an attacker can modify a class's internal state
 * if it doesn't use defensive copying for mutable output values.
 */
public class MutabilityExploit {
    public static void main(String[] args) {
        System.out.println("=== Lab 6-2: Mutability - Defensive Copying ===\n");

        VulnerableUserRegistry vulnerableRegistry = new VulnerableUserRegistry();
        SecureUserRegistry secureRegistry = new SecureUserRegistry();

        // 1. Exploit the vulnerable service
        System.out.println("[Step 1] Exploiting Vulnerable Service...");
        List<String> vulnerableList = vulnerableRegistry.getUsers();
        System.out.println("Initial Users: " + vulnerableList);

        // Attacker adds themselves to the list they shouldn't be able to modify
        vulnerableList.add("attacker_user");

        System.out
                .println("Users in Vulnerable Registry after 'get' and modification: " + vulnerableRegistry.getUsers());

        System.out.println("\n--------------------------------------------------\n");

        // 2. Attempt the same on the Secure Service
        System.out.println("[Step 2] Attempting to exploit Secure Service...");
        List<String> secureList = secureRegistry.getUsers();
        System.out.println("Initial Users: " + secureList);

        try {
            // Attempt to modify the returned list.
            // In SecureUserRegistry, this will be an UnmodifiableList.
            secureList.add("attacker_user");
            System.out.println("Modification succeeded (this should not happen!)");
        } catch (UnsupportedOperationException e) {
            System.err.println("CAUGHT EXPECTED EXCEPTION: " + e.getClass().getSimpleName());
            System.out.println("The Secure Service successfully protected its internal state.");
        }

        System.out.println("Users in Secure Registry remain unchanged: " + secureRegistry.getUsers());
    }
}
